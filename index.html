<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>미친 키보드 서바이벌</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser3-rex-plugins@1.1.57/dist/rexvirtualjoystickplugin.min.js"></script>
    <style>
        body { margin: 0; background: #222; overflow: hidden; touch-action: none; }
    </style>
</head>
<body>
    <script>
        const config = {
            type: Phaser.AUTO,
            scale: {
                mode: Phaser.Scale.FIT, // 모바일 화면에 꽉 차게 맞춤
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: 800,
                height: 600
            },
            backgroundColor: '#333333',
            physics: { default: 'arcade', arcade: { debug: false } },
            scene: { preload: preload, create: create, update: update }
        };

        const game = new Phaser.Game(config);

        let player;
        let otherPlayers;
        let cursors;
        let joyStick; // 조이스틱 변수
        let socket;
        let infoText;
        let timerText;
        let keyMap = { left: 'left', right: 'right', up: 'up', down: 'down' };
        let timeLeft = 3;

        function preload() {
            // 조이스틱 플러그인 로드 (URL 방식이라 여기서 할 건 없음)
        }

        function create() {
            const self = this;
            this.socket = io();
            this.otherPlayers = this.physics.add.group();

            // --- 조이스틱 생성 (화면 왼쪽 아래) ---
            joyStick = this.plugins.get('rexvirtualjoystickplugin').add(this, {
                x: 100,
                y: 500,
                radius: 60,
                base: this.add.circle(0, 0, 60, 0x888888, 0.5), // 회색 바닥
                thumb: this.add.circle(0, 0, 30, 0xcccccc, 0.9), // 흰색 손잡이
                dir: '4dir',   // 4방향 (8방향은 '8dir')
                forceMin: 16
            }).on('update', dumpJoyStickState, this);

            // 커서 키(키보드)도 계속 사용 가능
            cursors = this.joyStickCursors = joyStick.createCursorKeys();
            // 실제 키보드 입력과 조이스틱 입력을 합침
            const actualCursors = this.input.keyboard.createCursorKeys();

            // --- 소켓 통신 (이전과 동일) ---
            this.socket.on('currentPlayers', function (players) {
                Object.keys(players).forEach(function (id) {
                    if (players[id].playerId === self.socket.id) {
                        addPlayer(self, players[id]);
                    } else {
                        addOtherPlayers(self, players[id]);
                    }
                });
            });

            this.socket.on('newPlayer', function (playerInfo) {
                addOtherPlayers(self, playerInfo);
            });

            this.socket.on('disconnect', function (playerId) {
                self.otherPlayers.getChildren().forEach(function (otherPlayer) {
                    if (playerId === otherPlayer.playerId) {
                        otherPlayer.destroy();
                    }
                });
            });

            this.socket.on('playerMoved', function (playerInfo) {
                self.otherPlayers.getChildren().forEach(function (otherPlayer) {
                    if (playerInfo.playerId === otherPlayer.playerId) {
                        otherPlayer.setPosition(playerInfo.x, playerInfo.y);
                    }
                });
            });

            // UI 텍스트
            infoText = this.add.text(400, 50, '현재 상태: 정상', { fontSize: '32px', fill: '#FFF' }).setOrigin(0.5);
            timerText = this.add.text(400, 100, '다음 변경까지: 3초', { fontSize: '24px', fill: '#0F0' }).setOrigin(0.5);
            this.add.text(400, 550, 'PC: 방향키 / 모바일: 조이스틱', { fontSize: '16px', fill: '#AAA' }).setOrigin(0.5);

            this.time.addEvent({ delay: 1000, callback: updateTimer, callbackScope: this, loop: true });
            
            // 전역 변수로 키보드도 쓸 수 있게 저장
            this.actualCursors = actualCursors;
        }

        function dumpJoyStickState() {
            // 조이스틱 움직임 처리용 (필요시 사용)
        }

        function addPlayer(self, playerInfo) {
            self.player = self.add.rectangle(playerInfo.x, playerInfo.y, 40, 40, 0xFFFF00);
            self.physics.add.existing(self.player);
            self.player.body.setCollideWorldBounds(true);
        }

        function addOtherPlayers(self, playerInfo) {
            const otherPlayer = self.add.rectangle(playerInfo.x, playerInfo.y, 40, 40, 0x0000FF);
            otherPlayer.playerId = playerInfo.playerId;
            self.otherPlayers.add(otherPlayer);
        }

        function updateTimer() {
            timeLeft--;
            if (timeLeft <= 0) { timeLeft = 3; shuffleKeys(); }
            timerText.setText('다음 변경까지: ' + timeLeft + '초');
        }

        function shuffleKeys() {
            const mode = Phaser.Math.Between(0, 2);
            if (mode === 0) {
                keyMap = { left: 'left', right: 'right', up: 'up', down: 'down' };
                infoText.setText('상태: 정상'); infoText.setColor('#FFF');
            } else if (mode === 1) {
                keyMap = { left: 'right', right: 'left', up: 'down', down: 'up' };
                infoText.setText('상태: 청개구리!'); infoText.setColor('#F00');
            } else {
                const keys = ['left', 'right', 'up', 'down'];
                for (let i = keys.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [keys[i], keys[j]] = [keys[j], keys[i]];
                }
                keyMap = { left: keys[0], right: keys[1], up: keys[2], down: keys[3] };
                infoText.setText('상태: 뒤죽박죽'); infoText.setColor('#FF0');
            }
        }

        function update() {
            if (this.player) {
                const speed = 300;
                this.player.body.setVelocity(0);

                // ** 입력 합치기 (키보드 OR 조이스틱) **
                // cursors는 조이스틱, this.actualCursors는 실제 키보드
                const left = cursors.left.isDown || this.actualCursors.left.isDown;
                const right = cursors.right.isDown || this.actualCursors.right.isDown;
                const up = cursors.up.isDown || this.actualCursors.up.isDown;
                const down = cursors.down.isDown || this.actualCursors.down.isDown;

                // 미친 키보드 로직 적용
                if (left) movePlayer(this.player, keyMap.left, speed);
                if (right) movePlayer(this.player, keyMap.right, speed);
                if (up) movePlayer(this.player, keyMap.up, speed);
                if (down) movePlayer(this.player, keyMap.down, speed);

                // 서버 전송
                if (this.player.body.velocity.x !== 0 || this.player.body.velocity.y !== 0) {
                    this.socket.emit('playerMovement', { x: this.player.x, y: this.player.y });
                }
            }
        }

        function movePlayer(player, direction, speed) {
            if (direction === 'left') player.body.setVelocityX(-speed);
            if (direction === 'right') player.body.setVelocityX(speed);
            if (direction === 'up') player.body.setVelocityY(-speed);
            if (direction === 'down') player.body.setVelocityY(speed);
        }
    </script>
</body>
</html>